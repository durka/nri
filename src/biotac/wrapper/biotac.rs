#![allow(dead_code, non_snake_case, non_camel_case_types)]
/* automatically generated by rust-bindgen */

pub type BOOL = ::libc::c_int;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_long;
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulong;
pub type int_least8_t = ::libc::c_char;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_char;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intptr_t = ::libc::c_long;
pub type uintptr_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type u08 = uint8_t;
pub type _u16 = uint16_t;
pub type _u32 = uint32_t;
pub type U64 = uint64_t;
pub type s08 = int8_t;
pub type s16 = int16_t;
pub type s32 = int32_t;
pub type s64 = int64_t;
pub type Enum_CheetahStatus = ::libc::c_int;
pub const CH_OK: ::libc::c_int = 0;
pub const CH_UNABLE_TO_LOAD_LIBRARY: ::libc::c_int = -1;
pub const CH_UNABLE_TO_LOAD_DRIVER: ::libc::c_int = -2;
pub const CH_UNABLE_TO_LOAD_FUNCTION: ::libc::c_int = -3;
pub const CH_INCOMPATIBLE_LIBRARY: ::libc::c_int = -4;
pub const CH_INCOMPATIBLE_DEVICE: ::libc::c_int = -5;
pub const CH_INCOMPATIBLE_DRIVER: ::libc::c_int = -6;
pub const CH_COMMUNICATION_ERROR: ::libc::c_int = -7;
pub const CH_UNABLE_TO_OPEN: ::libc::c_int = -8;
pub const CH_UNABLE_TO_CLOSE: ::libc::c_int = -9;
pub const CH_INVALID_HANDLE: ::libc::c_int = -10;
pub const CH_CONFIG_ERROR: ::libc::c_int = -11;
pub const CH_UNKNOWN_PROTOCOL: ::libc::c_int = -12;
pub const CH_STILL_ACTIVE: ::libc::c_int = -13;
pub const CH_FUNCTION_NOT_AVAILABLE: ::libc::c_int = -14;
pub const CH_OS_ERROR: ::libc::c_int = -15;
pub const CH_SPI_WRITE_ERROR: ::libc::c_int = -100;
pub const CH_SPI_BATCH_EMPTY_QUEUE: ::libc::c_int = -101;
pub const CH_SPI_BATCH_SHORT_BUFFER: ::libc::c_int = -102;
pub const CH_SPI_ASYNC_EMPTY: ::libc::c_int = -103;
pub const CH_SPI_ASYNC_PENDING: ::libc::c_int = -104;
pub const CH_SPI_ASYNC_MAX_REACHED: ::libc::c_int = -105;
pub const CH_SPI_ASYNC_EXCESS_DELAY: ::libc::c_int = -106;
pub type CheetahStatus = Enum_CheetahStatus;
pub type Cheetah = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheetahVersion {
    pub software: _u16,
    pub firmware: _u16,
    pub hardware: _u16,
    pub hw_revs_for_sw: _u32,
    pub fw_revs_for_sw: _u32,
    pub drv_revs_for_sw: _u32,
    pub api_req_by_sw: _u16,
}
impl ::std::clone::Clone for Struct_CheetahVersion {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheetahVersion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheetahVersion = Struct_CheetahVersion;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheetahExt {
    pub version: CheetahVersion,
    pub features: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CheetahExt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheetahExt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheetahExt = Struct_CheetahExt;
pub type Enum_CheetahSpiPolarity = ::libc::c_uint;
pub const CH_SPI_POL_RISING_FALLING: ::libc::c_uint = 0;
pub const CH_SPI_POL_FALLING_RISING: ::libc::c_uint = 1;
pub type CheetahSpiPolarity = Enum_CheetahSpiPolarity;
pub type Enum_CheetahSpiPhase = ::libc::c_uint;
pub const CH_SPI_PHASE_SAMPLE_SETUP: ::libc::c_uint = 0;
pub const CH_SPI_PHASE_SETUP_SAMPLE: ::libc::c_uint = 1;
pub type CheetahSpiPhase = Enum_CheetahSpiPhase;
pub type Enum_CheetahSpiBitorder = ::libc::c_uint;
pub const CH_SPI_BITORDER_MSB: ::libc::c_uint = 0;
pub const CH_SPI_BITORDER_LSB: ::libc::c_uint = 1;
pub type CheetahSpiBitorder = Enum_CheetahSpiBitorder;
pub type BioTac = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub index: ::libc::c_int,
    pub time: ::libc::c_double,
    pub frame_index: ::libc::c_double,
    pub batch_index: ::libc::c_double,
    pub channel_id: u08,
    pub d: [Union_Unnamed2; 3usize],
    pub bt_parity: [u08; 3usize],
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed2 {
    pub _bindgen_data_: [u16; 1usize],
}
impl Union_Unnamed2 {
    pub unsafe fn word(&mut self) -> *mut _u16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn byte(&mut self) -> *mut [u08; 2usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bt_data = Struct_Unnamed1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub flex_version: [u08; 100usize],
    pub firmware_version: [u08; 100usize],
    pub serial_number: [u08; 100usize],
    pub cpu_speed: Union_Unnamed4,
    pub bt_connected: BOOL,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed4 {
    pub _bindgen_data_: [u16; 1usize],
}
impl Union_Unnamed4 {
    pub unsafe fn value(&mut self) -> *mut _u16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn byte(&mut self) -> *mut [u08; 2usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bt_property = Struct_Unnamed3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub spi_clock_speed: ::libc::c_int,
    pub number_of_biotacs: ::libc::c_int,
    pub sample_rate_Hz: ::libc::c_int,
    pub frame: Struct_Unnamed6,
    pub batch: Struct_Unnamed7,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub frame_type: ::libc::c_int,
    pub frame_size: ::libc::c_int,
    pub frame_structure: [::libc::c_char; 100usize],
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub batch_frame_count: ::libc::c_int,
    pub batch_ms: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bt_info = Struct_Unnamed5;
extern "C" {
    pub fn ch_find_devices(num_devices: ::libc::c_int, devices: *mut _u16)
     -> ::libc::c_int;
    pub fn ch_find_devices_ext(num_devices: ::libc::c_int, devices: *mut _u16,
                               num_ids: ::libc::c_int, unique_ids: *mut _u32)
     -> ::libc::c_int;
    pub fn ch_open(port_number: ::libc::c_int) -> Cheetah;
    pub fn ch_open_ext(port_number: ::libc::c_int, ch_ext: *mut CheetahExt)
     -> Cheetah;
    pub fn ch_close(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_port(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_unique_id(cheetah: Cheetah) -> _u32;
    pub fn ch_status_string(status: ::libc::c_int) -> *const ::libc::c_char;
    pub fn ch_version(cheetah: Cheetah, version: *mut CheetahVersion)
     -> ::libc::c_int;
    pub fn ch_sleep_ms(milliseconds: _u32) -> _u32;
    pub fn ch_target_power(cheetah: Cheetah, power_flag: u08)
     -> ::libc::c_int;
    pub fn ch_host_ifce_speed(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_dev_addr(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_spi_bitrate(cheetah: Cheetah, bitrate_khz: ::libc::c_int)
     -> ::libc::c_int;
    pub fn ch_spi_configure(cheetah: Cheetah, polarity: CheetahSpiPolarity,
                            phase: CheetahSpiPhase,
                            bitorder: CheetahSpiBitorder, ss_polarity: u08)
     -> ::libc::c_int;
    pub fn ch_spi_queue_clear(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_spi_queue_oe(cheetah: Cheetah, oe: u08) -> ::libc::c_int;
    pub fn ch_spi_queue_delay_cycles(cheetah: Cheetah, cycles: ::libc::c_int)
     -> ::libc::c_int;
    pub fn ch_spi_queue_delay_ns(cheetah: Cheetah, nanoseconds: ::libc::c_int)
     -> ::libc::c_int;
    pub fn ch_spi_queue_ss(cheetah: Cheetah, active: u08) -> ::libc::c_int;
    pub fn ch_spi_queue_byte(cheetah: Cheetah, count: ::libc::c_int,
                             data: u08) -> ::libc::c_int;
    pub fn ch_spi_queue_array(cheetah: Cheetah, num_bytes: ::libc::c_int,
                              data_out: *const u08) -> ::libc::c_int;
    pub fn ch_spi_batch_length(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_spi_batch_shift(cheetah: Cheetah, num_bytes: ::libc::c_int,
                              data_in: *mut u08) -> ::libc::c_int;
    pub fn ch_spi_async_submit(cheetah: Cheetah) -> ::libc::c_int;
    pub fn ch_spi_async_collect(cheetah: Cheetah, num_bytes: ::libc::c_int,
                                data_in: *mut u08) -> ::libc::c_int;
    pub fn bt_cheetah_initialize(biotac: *const bt_info,
                                 ch_handle: *mut Cheetah) -> BioTac;
    pub fn bt_cheetah_get_properties(ch_handle: Cheetah,
                                     bt_select: ::libc::c_int,
                                     property: *mut bt_property) -> BioTac;
    pub fn bt_cheetah_configure_batch(ch_handle: Cheetah,
                                      biotac: *mut bt_info,
                                      num_samples: ::libc::c_int) -> BioTac;
    pub fn bt_configure_save_buffer(num_samples: ::libc::c_int)
     -> *mut bt_data;
    pub fn bt_cheetah_collect_batch(ch_handle: Cheetah,
                                    biotac: *const bt_info,
                                    data: *mut bt_data, print_flag: BOOL)
     -> ();
    pub fn bt_display_errors(bt_err_code: BioTac) -> ();
    pub fn bt_save_buffer_data(file_name: *const ::libc::c_char,
                               data: *const bt_data,
                               num_samples: ::libc::c_int) -> BioTac;
    pub fn bt_cheetah_close(ch_handle: Cheetah) -> ();
}
